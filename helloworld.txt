# สถาปัตยกรรมคอมพิวเตอร์และระบบการทำงานเบื้องต้น (Computer Organization and Architecture)

เอกสารฉบับนี้สรุปเนื้อหาสำคัญเกี่ยวกับสถาปัตยกรรมคอมพิวเตอร์ ตั้งแต่ระดับของภาษาโปรแกรม การทำงานของหน่วยประมวลผลกลาง ระบบจำนวนและคณิตศาสตร์คอมพิวเตอร์ ไปจนถึงการจัดการหน่วยความจำ

## 1. ระดับของภาษาคอมพิวเตอร์ (Programming Languages)

ภาษาคอมพิวเตอร์ถูกแบ่งออกเป็นระดับต่างๆ ตามความใกล้เคียงกับภาษาที่มนุษย์เข้าใจและภาษาที่เครื่องจักรเข้าใจ

### 1.1 ภาษาระดับสูง (High-Level Language)
เป็นภาษาที่มีโครงสร้างไวยากรณ์คล้ายคลึงกับภาษามนุษย์ (ภาษาอังกฤษ) ทำให้ง่ายต่อการอ่านและเขียน แบ่งรูปแบบการเขียน (Paradigm) ออกเป็นหลายประเภท ได้แก่:
* **Procedural Programming:** เน้นการทำงานตามลำดับขั้นตอน (เช่น Pascal, FORTRAN, C)
* **Functional Programming:** เน้นการคำนวณผ่านฟังก์ชันทางคณิตศาสตร์
* **Object-Oriented Programming (OOP):** เน้นการมองทุกอย่างเป็นวัตถุที่มีคุณสมบัติและพฤติกรรม

### 1.2 ภาษาระดับต่ำ (Low-Level Language)
* **ภาษาสัญลักษณ์ (Assembly Language):** เป็นภาษาที่ใช้ตัวอักษรย่อ (Mnemonic) แทนคำสั่งภาษาเครื่อง โดยมีความสัมพันธ์กับคำสั่งภาษาเครื่องแบบ 1 ต่อ 1 ต้องใช้โปรแกรม **Assembler** ในการแปลภาษา
* **ภาษาเครื่อง (Machine Language):** ระดับต่ำที่สุด อยู่ในรูปแบบเลขฐานสอง (เช่น `101101`) ซึ่งคอมพิวเตอร์สามารถนำไปประมวลผลได้ทันที

---

## 2. องค์ประกอบของคอมพิวเตอร์ (Computer Components)



[Image of CPU architecture block diagram]


### 2.1 หน่วยประมวลผลกลาง (CPU: Central Processing Unit)
CPU ทำหน้าที่เป็นสมองของคอมพิวเตอร์ ประกอบด้วยส่วนสำคัญ ดังนี้:
* **ALU (Arithmetic Logic Unit):** หน่วยประมวลผลทางคณิตศาสตร์และตรรกะ ทำหน้าที่คำนวณและเปรียบเทียบข้อมูล
* **CU (Control Unit):** หน่วยควบคุม ทำหน้าที่ควบคุมการทำงานของฮาร์ดแวร์ชิ้นอื่นๆ และจัดการจังหวะการทำงาน
* **Registers:** หน่วยความจำขนาดเล็กที่อยู่ภายใน CPU มีความเร็วสูงมาก ใช้สำหรับพักข้อมูลชั่วคราวระหว่างการประมวลผล
    * *ข้อสังเกตเรื่องขนาดของ Register:* หากใช้งาน Register ขนาด 8 บิต (เช่น `AL`) จะสามารถเก็บข้อมูลได้ $2^8 = 256$ ค่า คือตั้งแต่ $0$ ถึง $255$ (สำหรับจำนวนเต็มบวก) หรือ $-128$ ถึง $127$ (สำหรับจำนวนเต็มแบบมีเครื่องหมาย) หากป้อนค่าที่เกินกว่านี้ (เช่น 300) จะเกิดสภาวะข้อมูลล้น (Overflow)
    * ขนาดอื่นๆ: 16-bit จุได้ $2^{16} = 65,536$ ค่า

### 2.2 วงรอบการทำงานของคำสั่ง (Machine Cycle)
การประมวลผล 1 คำสั่งของ CPU จะประกอบด้วย 3 ขั้นตอนหลัก (วนซ้ำไปเรื่อยๆ):
1.  **Fetch (การดึงคำสั่ง):** ดึงคำสั่งจากหน่วยความจำหลัก (RAM) เข้ามาเก็บไว้ใน Instruction Register (IR) โดยอาศัยตัวชี้ตำแหน่งที่เรียกว่า Program Counter (PC) หรือ Instruction Pointer (IP)
2.  **Decode (การถอดรหัส):** นำคำสั่งที่ได้มาถอดรหัส เพื่อให้ CU ทราบว่าต้องสั่งการฮาร์ดแวร์ส่วนใด (เช่น สั่ง ALU ให้บวกเลข)
3.  **Execute (การประมวลผล):** ดำเนินการตามคำสั่งที่ถอดรหัสไว้

### 2.3 ลำดับชั้นของหน่วยความจำ (Memory Hierarchy)



[Image of computer memory hierarchy diagram]


CPU จะประมวลผลข้อมูลได้ก็ต่อเมื่อข้อมูลนั้นอยู่ในระดับ Level 0 หรือ Level 1 เท่านั้น
* **Level 0 (Cache Memory):** เป็นหน่วยความจำแบบ SRAM (Static RAM) ที่เร็วที่สุด อยู่ใกล้หรืออยู่ใน CPU
* **Level 1 (Main Memory):** หน่วยความจำหลักหรือ RAM (Random Access Memory) ประเภท DRAM (Dynamic RAM) เป็นหน่วยความจำชั่วคราว (Volatile) หากปิดเครื่องข้อมูลจะสูญหาย
* **Level 2 ขึ้นไป (Secondary Storage):** หน่วยความจำรอง เช่น Harddisk (HD), SSD, CD-ROM เป็นหน่วยความจำถาวร (Non-volatile) 
* *กลไกการโหลดข้อมูล:* หากข้อมูลที่ CPU ต้องการอยู่ใน Level 2 ระบบจะต้องโหลดข้อมูลนั้นมาพักที่ Level 1 และ Level 0 ตามลำดับก่อน จึงจะนำไปประมวลผลได้

---

## 3. ระบบจำนวน (Number Systems)

คอมพิวเตอร์ใช้ระบบเลขฐานสองเป็นหลัก แต่เพื่อความสะดวกของมนุษย์ จึงมีการใช้เลขฐานสิบหกเข้ามาช่วยย่อขนาดข้อความ

### 3.1 เลขฐานสิบหก (Hexadecimal)
ใช้สัญลักษณ์ 16 แบบ คือ $0-9$ และ $A-F$ (โดย $A=10, B=11, ..., F=15$)
เลขฐานสิบหก 1 หลัก สามารถแปลงเป็นเลขฐานสองได้ 4 หลักเสมอ เช่น:
* $41_{16} = 0100 0001_2$ (รหัส ASCII ของตัวอักษร 'A')
* $42_{16} = 0100 0010_2$ (รหัส ASCII ของตัวอักษร 'B')

### 3.2 การแปลงเลขฐานสิบที่มีทศนิยม เป็นฐานสอง
ตัวอย่างการแปลงค่า $10.625_{10}$:
1.  **ส่วนจำนวนเต็ม (10):** หารสั้นด้วย 2 จะได้ $1010_2$
2.  **ส่วนทศนิยม (0.625):** นำไปคูณด้วย 2 แล้วเก็บเลขหน้าจุดทศนิยม
    * $0.625 \times 2 = 1.25$ (เก็บ $1$)
    * $0.250 \times 2 = 0.50$ (เก็บ $0$)
    * $0.500 \times 2 = 1.00$ (เก็บ $1$)
3.  **ผลลัพธ์:** $10.625_{10} = 1010.101_2$

---

## 4. การแทนค่าตัวเลขติดลบในคอมพิวเตอร์

คอมพิวเตอร์ไม่มีเครื่องหมายลบ (-) จึงต้องใช้บิตซ้ายสุด (MSB: Most Significant Bit) เป็นตัวบอกเครื่องหมาย มีวิธีการจัดเก็บ 2 รูปแบบหลัก คือ:

### 4.1 Signed Magnitude กับ Two's Complement (กรณีขนาด 4 บิต)

| ค่าฐานสิบ | Signed Magnitude | Two's Complement | วิธีคิด Two's Complement (บิตซ้ายสุดติดลบ) |
| :---: | :---: | :---: | :--- |
| **+7** | `0111` | `0111` | $(0 \times -8) + 4 + 2 + 1 = 7$ |
| **+1** | `0001` | `0001` | $(0 \times -8) + 1 = 1$ |
| **0** | `0000` | `0000` | $0$ |
| **-0** | `1000` | - (ไม่มี -0) | - |
| **-1** | `1001` | `1111` | $(1 \times -8) + 4 + 2 + 1 = -1$ |
| **-2** | `1010` | `1110` | $(1 \times -8) + 4 + 2 = -2$ |
| **-7** | `1111` | `1001` | $(1 \times -8) + 1 = -7$ |
| **-8** | (เก็บไม่ได้) | `1000` | $(1 \times -8) = -8$ |

* **ข้อดีของ Two's Complement:** ไม่มีปัญหาเรื่องศูนย์สองค่า ($+0$ และ $-0$) และสามารถนำข้อมูลฐานสองมาบวกลบกันตามหลักคณิตศาสตร์ได้เลย เช่น การคำนวณ $A - B$ จะมีค่าเท่ากับ $A + \text{Two's Complement}(B)$
* **วิธีหา Two's Complement:** ให้กลับบิต (0 เป็น 1, 1 เป็น 0 เรียกว่า One's Complement) แล้วนำผลลัพธ์ไปบวกเพิ่มอีก 1

### 4.2 การเลื่อนบิต (Bit Shifting)
* **เลื่อนซ้าย (Shift Left `<<`):** การเลื่อนบิตไปทางซ้าย 1 ตำแหน่ง มีค่าเทียบเท่ากับ **การคูณด้วย 2** จำนวน 1 ครั้ง
    * ตัวอย่าง: $5 \ll 1$ ($0000 0101_2$ เลื่อนเป็น $0000 1010_2$) ผลลัพธ์คือ $10_{10}$
    * ตัวอย่าง: $5 \ll 2$ ผลลัพธ์คือ $20_{10}$

---

## 5. การอ้างอิงตำแหน่งหน่วยความจำ (Memory Addressing)

ในยุคของ CPU Intel 8086 (สถาปัตยกรรม 16 บิต) มีข้อจำกัดคือ Register ภายในมีขนาดเพียง 16 บิต ซึ่งอ้างอิงตำแหน่งได้สูงสุดเพียง $FFFF_{16}$ หรือ $64\text{ KB}$ แต่ตัวเมนบอร์ดรองรับหน่วยความจำทางกายภาพ (Physical Memory) ได้ถึง 20 บิต ($1\text{ MB}$)

จึงเกิดเทคนิคการแบ่งส่วนหน่วยความจำ (Segmented Memory) ขึ้น โดยอาศัย Register 2 ตัวทำงานร่วมกัน คือ:
$$\text{Physical Address} = (\text{Segment} \ll 4) + \text{Offset}$$

**ตัวอย่าง:** หากค่า Logical Address คือ `2500:95F3`
* เลื่อน Segment `2500` ไปทางซ้าย 4 บิต (หรือเติม 0 ต่อท้าย 1 ตัวในฐานสิบหก) จะได้ `25000`
* นำไปบวกกับ Offset `95F3`
* $25000 + 95F3 = \mathbf{2E5F3}$ (นี่คือ Physical Address ขนาด 20 บิตที่แท้จริง)

---

## 6. โครงงานโปรเจกต์: หนังสือ Comorg-Book-Thai

**เป้าหมาย:** จัดทำหนังสือวิชาสถาปัตยกรรมคอมพิวเตอร์ฉบับภาษาไทย ผ่านระบบ Version Control

**ขั้นตอนและเครื่องมือ:**
1.  **แบ่งงาน:** แบ่งเนื้อหา PDF (เช่น Chapter 4 - 8) ให้สมาชิกแต่ละคนรับผิดชอบแต่ละหัวข้อย่อย
2.  **การแปลงไฟล์เอกสาร:** > *ข้อแนะนำจากระบบ:* ตามบันทึกมีการระบุถึงเครื่องมือ Pandoc หรือ Markdown-it ในการดึง Text ออกจาก PDF อย่างไรก็ตาม เพื่อประสิทธิภาพสูงสุดในการดึงข้อความล้วน แนะนำให้ใช้เครื่องมือประเภท `pdftotext` (Xpdf) จะตรงจุดประสงค์มากกว่า
3.  **การแปลและเรียบเรียง:** นำข้อความที่สกัดได้ มาแปลและเรียบเรียงเป็นภาษาทางการสำหรับหนังสือวิชาการคอมพิวเตอร์
4.  **การจัดการผ่าน Git & GitHub:**
    * ใช้ Repository หลักร่วมกันชื่อ `comorg-book-thai`
    * สมาชิกแต่ละคนต้องสร้าง Branch แยก (Branching) เพื่อทำงานในส่วนของตนเอง
    * เมื่อเรียบเรียงและเขียนด้วย Markdown เสร็จสิ้น ให้ทำการ Merge กลับเข้าสู่ Branch หลัก (Main)

```bash
# ตัวอย่างชุดคำสั่งเริ่มต้นสำหรับโครงงาน
mkdir comorg-book-thai
cd comorg-book-thai
git init
```